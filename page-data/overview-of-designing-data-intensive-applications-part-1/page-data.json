{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/overview-of-designing-data-intensive-applications-part-1","result":{"data":{"post":{"__typename":"MdxPost","slug":"/overview-of-designing-data-intensive-applications-part-1","title":"Overview of \"Designing Data-Intensive Applications\" Part 1","date":"16.12.2020","tags":[{"name":"Books","slug":"books"},{"name":"Distributed Systems","slug":"distributed-systems"},{"name":"Databases","slug":"databases"},{"name":"System Design","slug":"system-design"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Overview of \\\"Designing Data-Intensive Applications\\\" Part 1\",\n  \"date\": \"2020-12-16T00:00:00.000Z\",\n  \"tags\": [\"Books\", \"Distributed Systems\", \"Databases\", \"System Design\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In Designing Data-Intensive Applications, Martin Kleppmann\\ndiscusses problems and solutions that define modern system design where there\\nis an arms-race between the ever-increasing amount of data collected and\\nused in applications and the software and system design paradigms that\\nneed to keep up and scale with it while also providing acceptable service to end users.\"), mdx(\"p\", null, \"This book is clearly written for working professionals who have\\nprobably had first-hand experience with distributed systems and all\\nthe accompanying bugs and issues. Despite this, a computer science student or\\naspiring software engineer will be able to benefit reading this book if they\\nhave some background in databases and their underlying data structures/implementations, networking, and concurrency.\\nPersonally, I was better able to understand topics such as event streams after\\ncompleting an internship at Amazon; having gained concrete experience working\\nwith different components of a distributed system naturally helped draw connections from\\nconcepts discussed in the book to real-world applications.\"), mdx(\"p\", null, \"Kleppmann partitions his book into 3 distinct parts which will serve as\\nthe structure for the rest of this overview and subsequent posts covering the latter 2 parts.\"), mdx(\"h2\", null, \"1. Foundations of Data Systems\"), mdx(\"p\", null, \"Well designed systems are:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Reliable - they work as intended and are fault tolerant\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Scalable - they can handle growth (users, requests, data, etc.)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Maintainable - engineers can monitor and make changes without creating unecessary downtime\")), mdx(\"p\", null, \"When designing data-intensive systems, every decision should be evaluated based on its impact on reliability,\\nscalability, and maintainability. In almost all cases, a trade-off is present.\\nThe job of the designer is to identify the trade-offs and make educated decisions based on the requirements of the system. Even then,\\ndesigners cannot expect their designs to always be optimal because requirements evolve with business needs.\"), mdx(\"p\", null, \"In the first sections of the book, Kleppmann focuses on decisions that need to be made even if the entire\\nsystem is just one machine; the reasoning behind this is that a system design should work well for one machine\\nor else it will be difficult to scale to several servers in a distributed system. These decisions involve determining\\nhow data will be represented, stored, and used in the system. More specifically, we need to decide what data models to use and\\nwhat retrieval patterns do we expect for the data by other applications.\"), mdx(\"h3\", null, \"Data Models\"), mdx(\"p\", null, \"For data models, there are 2 primary options: the relational and document models.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Relational Model\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Document Model\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"schema-on-write\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"schema-on-read\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"better join support\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"poor join support\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"impendance mismatch (disconnect between application code and database models)\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"JSON formats tend to have lower impendance mismatch\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"can model one-to-many, many-to-one relationships\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"cannot easily refer directly to nested items\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"declarative languages like SQL provide behind-the-scenes query optimization\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"imperative languages perform DB operations in the specified order, regardless of performance\")))), mdx(\"p\", null, \"Modern relational and document databases have converged in terms of performance and what features they offer.\\nReliable and scalable systems can be built with either data model. What should drive the\\ndesicion-making process between the 2 models is maintainability. \"), mdx(\"p\", null, \"A poorly chosen data model\\nwill lead to maintainability issues further down the road because data naturally evolves and tends to become\\nmore interconnected and complex. The schema flexibility offered by document-based models is a good hedge against increasing\\ncomplexity as new data fields can be simply added without the changing of schemas or creating new tables that would occur in the relational case.\\nDespite this, problems arise when the interconnectedness of the data warrants the modelling of both one-to-many and many-to-one relationships.\\nIn this case, relational data models would be a better solution.\\nDocument-based models often offer JSON as a data format for representing\\ndatabase entries. JSON is easy to work with in most programming languages, making\\ndevelopment easier/faster, however, nested items are not easily accessible. If requirements change such that\\na data field that is nested deep inside the document tree needs to now be accessed frequently, maintainability issues arise as application code becomes more complex to support this requirement.\"), mdx(\"h3\", null, \"Retrieval Patterns\"), mdx(\"p\", null, \"Data retrieval patterns define the read and write requirements for a database.\\nThe book discusses 2 main patterns for data retrieval and usage.\\nWeb applications, social networks, and other common systems where there are several users\\nreading data and updating/posting new data fall under \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"online transactional processing\"), \" (OLTP) use cases.\\nUsers read and write small amounts of data at a time, but they expect these operations to be instant and interactive.\\nThe other pattern involves reading large chunks of data (or the entire database) at once to perform\\nsome calculations/aggregations. This is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"online analytic processing\"), \" (OLAP) use case and a common task performed by business\\nanalysts and engineers. \"), mdx(\"p\", null, \"This chart borrowed from the book illustrates the differences between OLTP and OLAP:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Property\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"OLTP\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"OLAP\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Main read pattern\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"small number of records per query\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"aggregate over large number of records\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Main write pattern\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"random-access, low-latency writes\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"bulk import, event streams\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Primarily used by\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"end-users\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"internal analysts, engineers\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"What data represents\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"latest state of data\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"history of events\")))), mdx(\"p\", null, \"Because OLTP and OLAP systems serve very different purposes, it has become common practice to separate\\nthe 2 even if they essentially represent the same data. Large enteprises now use data warehouses\\noptimized for bulk reads for their OLAP needs. Data warehouses diverge significantly from\\nrelational and document databases used for OLTP in implementation. For example, techniques such as column-oriented storage\\nare used in data warehouses because they make bulk reads more efficient.\"), mdx(\"h3\", null, \"Other Considerations\"), mdx(\"p\", null, \"In Part 1, Kleppmann also discusses topics such as the underlying data structures that\\nstore data efficiently in a database and different data encoding methods/tools.\\nThese topics are good to know for the sake of better understanding how databases work\\nunder the hood. However, the purpose of database software is to abstract away from working directly\\nwith the file system and data structures like B-trees. As long as application data is modelled correctly and proper\\ncare is taken in defining read and write expectations, any modern database engine should suffice without having to think about\\nits underlying implementation. \"), mdx(\"p\", null, \"In the subsequent parts, things will get more complex as more machines will be introduced into the system.\\nAs the system scales, networking and database concurrency problems begin to negatively impact reliability and maintainability.\\nMuch of the research in distributed systems aims to develop solutions to these issues that will be discussed in the next post.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"In Designing Data-Intensive Applications, Martin Kleppmann \ndiscusses problems and solutions that define modern system design where there\nis…","timeToRead":4,"banner":null}},"pageContext":{"slug":"/overview-of-designing-data-intensive-applications-part-1","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}
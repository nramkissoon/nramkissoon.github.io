{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/creating-a-graph-ql-server-for-japanese-morphological-analysis","result":{"data":{"post":{"__typename":"MdxPost","slug":"/creating-a-graph-ql-server-for-japanese-morphological-analysis","title":"Creating a GraphQL Server for Japanese Morphological Analysis","date":"01.02.2021","tags":[{"name":"Projects","slug":"projects"},{"name":"API Design","slug":"api-design"},{"name":"GraphQL","slug":"graph-ql"},{"name":"NodeJS","slug":"node-js"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Creating a GraphQL Server for Japanese Morphological Analysis\",\n  \"date\": \"2021-02-01T00:00:00.000Z\",\n  \"tags\": [\"Projects\", \"API Design\", \"GraphQL\", \"NodeJS\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Repository: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/nramkissoon/morph-analyzer-service-for-japanese\"\n  }), \"https://github.com/nramkissoon/morph-analyzer-service-for-japanese\")), mdx(\"p\", null, \"In order to learn how GraphQL works and practice using Docker,\\nI decided to develop this small server project that exposes a GraphQL API\\none can use to interact with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://taku910.github.io/mecab/\"\n  }), \"MeCab\"), \", a morphological\\nanalyzer for the Japanese language. Setting up MeCab on a machine is a pain so Docker is used to install\\nMeCab and dictionary dependencies in a container for portability to any machine.\"), mdx(\"h2\", null, \"GraphQL API\"), mdx(\"p\", null, \"A single query is implemented that takes in a text argument:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query{\\n  tokenize(text:\\\"\\u5927\\u7D71\\u9818\\\") {\\n    words {\\n      kanji\\n      pronunciation\\n      lexical\\n      compound1\\n      compound2\\n      compound3\\n      reading\\n      conjugation\\n    }\\n    error {\\n      name\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The server tokenizes the text and returns data related to each token as specified by the query:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"tokenize\\\": {\\n      \\\"words\\\": [\\n        {\\n          \\\"kanji\\\": \\\"\\u5927\\u7D71\\u9818\\\",\\n          \\\"pronunciation\\\": \\\"\\u30C0\\u30A4\\u30C8\\u30FC\\u30EA\\u30E7\\u30FC\\\",\\n          \\\"lexical\\\": \\\"\\u540D\\u8A5E\\\",\\n          \\\"compound1\\\": \\\"\\u4E00\\u822C\\\",\\n          \\\"compound2\\\": null,\\n          \\\"compound3\\\": null,\\n          \\\"reading\\\": \\\"\\u30C0\\u30A4\\u30C8\\u30A6\\u30EA\\u30E7\\u30A6\\\",\\n          \\\"conjugation\\\": null\\n        }\\n      ],\\n      \\\"error\\\": null\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Here is where the benefits of GraphQL show up, if a client only needed the readings of the tokens in the text,\\nall they have to do is specify that in their query, and they'll only receive the data they requested.\"), mdx(\"h2\", null, \"Implementation Using TypeScript\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://typegraphql.com/\"\n  }), \"TypeGraphQL\"), \" is used to implement the GraphQL schema and resolvers for the API.\\nThe learning curve is pretty steep as I did not even know annotations existed in TypeScript.\\nHowever, being able to define the schema and types in TypeScript makes for a cleaner codebase.\"), mdx(\"p\", null, \"This is a sample type definition that is used in the GraphQL schema:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"@ObjectType()\\nexport class MecabOutputError {\\n    @Field(() => String)\\n    name: string;\\n    @Field(() => String)\\n    message: string;\\n}\\n\")), mdx(\"p\", null, \"This simply translates to a type called 'MecabOutputError' that has 2 string fields: name and message.\\nThe fields default to non-nullable.\"), mdx(\"p\", null, \"And here is a resolver:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"@Resolver()\\nexport class QueryResolver {\\n    @Query(() => MecabOutput, { nullable: false })\\n    tokenize(@Arg('text', () => String, { nullable: false }) text: string): MecabOutput {\\n        return mecabParseSync(text);\\n    }\\n}\\n\")), mdx(\"p\", null, \"When building a schema with TypeGraphQL, you can choose to emit a .gql schema file which contains the GraphQL translation\\nof the TypeScript schema you wrote. This is helpful for learning and debugging.\"), mdx(\"p\", null, \"For the above resolver, this is the equivalent GraphQL:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Query {\\n  tokenize(text: String!): MecabOutput!\\n}\\n\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.apollographql.com/docs/apollo-server/\"\n  }), \"Apollo Server\"), \" and Express is used for the actual server. Not much needs to be said here as the two\\nare easy to set up and integrate together using the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/apollo-server-express\"\n  }), \"apollo-server-express\"), \" package.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Repository:  https://github.com/nramkissoon/morph-analyzer-service-for-japanese In order to learn how GraphQL works and practice usingâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/creating-a-graph-ql-server-for-japanese-morphological-analysis","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}